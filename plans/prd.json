[
  {
    "id": "CHORE-001",
    "category": "chore",
    "title": "Create a new bash script in the server, that spawns Claude agent with prompt that can be passed as an argument",
    "steps": [
      "Create new module @server/src/ralph",
      "Create new bash script with execute permission",
      "As a parameter, pass the raw prompt and working directory for the claude",
      "Call Claude from the script simiarly how @plans/ralph.sh does it, however prompt should be passed as an argument to the script",
      "Make sure claude is working in the working directory of the script"
    ],
    "passes": true
  },
  {
    "id": "CHORE-002",
    "category": "chore",
    "title": "Create new service in the ralph module that would allow running ralph loop for a given prompt",
    "steps": [
      "Create new service file in the ralph module",
      "Call the ralph.sh script from the service, as a parameter pass both working directory and raw prompt (well provide ralph specific prompt later)",
      "Make sure all edge cases with IPC are covered (think of process termination, error handling, etc.)"
    ],
    "passes": true
  },
  {
    "id": "CHORE-003",
    "category": "chore",
    "title": "Build integration test that would run the ralph loop.",
    "steps": [
      "Create empty folder for the test that you always purge before running the test",
      "Gitingore the working directory for the test",
      "Provide testing prompt that would tell the service to create empty file with hello world",
      "Test that the file is created and contains hello world"
    ],
    "passes": true
  },
  {
    "id": "CHORE-004",
    "category": "chore",
    "title": "Decouple IO operations from the ralph service. Create utils that would cover the process management and then call it from the service",
    "steps": [
      "Create new module @server/src/utils/process.ts",
      "Create a function that would spawn a process and return a promise that would resolve when the process is terminated",
      "Call the utils from the service"
    ],
    "passes": true
  },
  {
    "id": "BUG-001",
    "category": "bug",
    "title": "Ralph service does not need to check for COMPLETE marker. It is already handled by the ralph.sh script",
    "steps": [
      "Remove the COMPLETE marker check from the ralph service",
      "spawn process should throw an error when the process is terminated with non-zero exit code",
      "spawn process should return  string only which is stdout, ignore stderr",
      "Simplify the service even more, the service should not worry about exit codec, just run the spawnProcess, log result and catch and log error if thrown"
    ],
    "passes": true
  },
  {
    "id": "FEAT-001",
    "category": "feat",
    "title": "Assemble Ralph loop prompt in the service",
    "steps": [
      "The prompt should be constructed in the service",
      "Service should not accept the raw prompt anymore",
      "Create prompt template in the service file",
      "Use very similar prompt that is in @plans/prompt.md",
      "Obviously skip the part about reading PRDs and progress, we'll provide this via the MCP later",
      "The prompt should be altered to use the tool calls to get the tasks and mark them as done instead of direct file manipulation",
      "Skip current test, we'll fix this in next stages"
    ],
    "passes": true
  },
  {
    "id": "CHORE-005",
    "category": "chore",
    "title": "Expose runRalph via the REST API so that we can start this manually for testing purposes",
    "steps": [
      "Create new endpoint POST /ralph in the server",
      "Adjust the integration test to use the new endpoint instead of manual run of the service",
      "Ensure no dependency on the server exists in the tests"
    ],
    "passes": true
  }
]
